概念1：每时钟像素数(stream接口)
概念2: stream接口格式(即native格式):RGB YUV YUV422 YUV420(分奇偶行) 除了yuv420外，字节间紧凑
概念3: 存储格式:RGBX8 RGB8 RGB10 BGR8  YUV4228 
概念4: MIG宽度
概念5: stream和native的选择

1 xilinx 的IP编写是动态可配置，所以它的stream接口的数据位宽是按照某种模式下最大的宽度算的；
  例如色深为8时，单像素的stream接口就是8*3=24 (YUV4228 也是24，有部分位宽就舍弃了)
2 因为技术不够，我们自己编写的模块只需要做到参数可配置
  而不需要做到动态可配置，这就意味着，stream的宽度会根据stream类型改变
      例如【 RGB时，单像素宽24；而yuv422时单像素宽16】
3 对于tpg强制输出数据，不允许下一级模块没有准备好
  对于stream流，则以一行为一个单元发送数据，以tlast结尾；
4 对于公司自定义yuv420存储格式 ：和 xilinx自定义格式有不同
  【公司的格式是 y00 y10 u y01 y11 v 代表四像素】
5 对于native格式，就要外部给一个和参数匹配的tpg模块
  对于axistream格式---当然可以用tpg模块转stream，但是内部直接用代码也可以解决
6 对于输入口，则native和stream的做法没有多大区别
7 对于frame reader, fifo输入端宽度当然就是mig宽度，这个可以随意；需要考虑的是fifo输出端宽度
8 对于frame reader的fifo输出端宽度，当然是越和 存储格式对应的单像素宽度*单时钟像素数 接近较好
                                    更准确的说，是实际存储中数据宽度
9 根据存储格式：可能出现以下的单像素字节数  3字节; 4字节; 2字节;  常见就这些;
  所以，fifo的输出端宽度最好接近  24*N  32*N  16*N   N= 1 2 4 8 
  所以，fifo输出端理想宽度为 ： 24  48   96   192
                                32  64   128  256    
                                16  (32   64   128)

即【fifo 输出理想宽度有  24  48   96   192  32  64   128  256   16 】
  fifo 输入宽度 32(xilinx也没有32 )  64(对应1像素)   128(对应2像素)   256(xilinx ip内对应每时钟四像素)   512(对应8像素) 
       可见，xilinx ip里应该也用了fifo做位宽转换，当需要的位宽很小时，mig的宽度就不能太大(fifo原语有1:8的最大位宽比限制)
  其实mig宽度只需要选256或512，更小的选项虽然也可以，但是没有太大意义
  
代码说明：
   1 建立一个表格用于计算合适的fifo位宽比
   2 宽度相差太大时，引入额外的fifo； 也可以不引入，这样一旦用户设置错参数就无法编译
   3 只需区分“匹配”和“不匹配”两种情况；这样状态机会很简单：匹配的一组状态机；不匹配的一组状态机；
                                                          420的一组状态机或融入不匹配的状态机(因为也是不匹配的)
   4 420要区分奇数偶数行
  
10 在理解frame buffer时，核心就是跨时钟的fifo，fifo发出的状态标志，以及用作同步的vs信号
11 有的时候会通过内部的tpg模块，把视频强行打出来
12 从mm拉数据到fifo vs 从fifo读取数据  独立
13 PIXEL_WIDTH            = 4  ,//输出口的像素宽度 
14 根据不同场景，有的时候只写fifo一侧的逻辑
15 可以灵活利用fifo的count值，对外提供各种标志信号
16  对于画面合并的要一并考虑进去